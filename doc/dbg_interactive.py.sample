# Example file for the dbg_interactive.fdx extension.
#
# This extension provides an interactive python interpreter console that allows
# interacting with freeDiameter framework.
#
# The adaptation layer between Python and C is provided by SWIG (http://swig.org). 
# You may refer to SWIG documentation for more information on how the wrapper is generated and used.
# The name of the module wrapping freeDiameter framework is: _fDpy
#
# Similar to all freeDiameter extensions, an optional filename can be specified in the
# main freeDiameter.conf configuration file for the dbg_interactive.fdx extension.
# If such file is provided, it will be passed to the python interpreter as a python script
# to execute. Otherwise, the interpreter will be interactive.
#
# SWIG deals with structures as follow:
# Given the structure:
# struct foo { int a; }
# The following functions are available to python (their C equivalent processing is given in [ ]):
# s = new_foo()	   [ s = calloc(1, sizeof(struct foo)) ]
# foo_a_set(s, 2)  [ s->a = 2 ]
# foo_a_get(s)     [ returns s->a value ]
# delete_foo(s)    [ free(s)  ]
#
# In addition, thanks to the proxy (aka shadow) class, we can also do the more user-friendly:
# s = foo()
# s.a = 2
# s.a
# del s
#

# The remaining of this file gives some examples of how to use the python interpreter.
# Note that the support is not yet totally usable. You'll probably have to extend some classes
# or write some typemaps in the source code of the extension to do what you want.


############# Compilation-time constants (from freeDiameter-host.h) ############

# Display current version
print "%s %d.%d.%d" % (FD_PROJECT_NAME, FD_PROJECT_VERSION_MAJOR, FD_PROJECT_VERSION_MINOR, FD_PROJECT_VERSION_REV)


############# Debug ############

# Change the global debug level of the framework (cvar contains all global variables)
cvar.fd_g_debug_lvl = FULL


# Turn on debug for a specific function (if framework compiled with DEBUG support)
cvar.fd_debug_one_function = "gc_th_fct"


# Print messages to freeDiameter's debug facility
# Note: the python version does not support printf-like argument list. The formating should be done in python.
#       See SWIG documentation about varargs functions for more information.
fd_log_debug("3 + 4 = %d\n" % (7))


# Display some framework state information
r = fd_event_send(cvar.fd_g_config.cnf_main_ev, FDEV_DUMP_PEERS, 0, None)
r = fd_event_send(cvar.fd_g_config.cnf_main_ev, FDEV_DUMP_SERV, 0, None)
r = fd_event_send(cvar.fd_g_config.cnf_main_ev, FDEV_DUMP_EXT, 0, None)


############# Global variables ############

# Display the local Diameter Identity:
print "Local Diameter Identity:", cvar.fd_g_config.cnf_diamid

# Display realm, using the low-level functions (skip proxy classe definitions):
print "Realm:", _fDpy.fd_config_cnf_diamrlm_get(_fDpy.cvar.fd_g_config)



############# Lists ############

# Note: we use different names from the C API here, for usability.
l1 = fd_list()   # Will be our sentinel
l2 = fd_list()
l3 = fd_list()
l1.isempty()
l1.insert_next(l2)   # l1 -> l2
l1.isempty()
l1.insert_prev(l3)   # l1 -> l2 -> l3 (circular list)
l1.dump()
l3.detach()          # l1 -> l2
l4=fd_list()
l5=fd_list()
l3.insert_next(l4)   #   l3 -> l4
l3.insert_next(l5)   #   l3 -> l5 -> l4
l1.concat(l3)        # l1 -> l2 -> l5 -> l4

elements = l1.enum_as()  # default: enumerates as fd_list. Warning: this a copy, changing the python list has no effect on the underlying list.
for li in elements:
  li.dump()

del elements
del l2
del l3
del l4
del l5
l1.isempty() # The destructor has an implicit fd_list_unlink call
del l1


############# Hash ############
hex(fd_hash("hello world"))	# A typemap is applied to accept binary data


############# Dictionary ############

##### Create a dedicated dictionary for our tests
d = dictionary()
d.dump()

# New vendor
v = dict_vendor_data()
v.vendor_id = 123
v.vendor_name = "My test vendor"
my_vendor = d.new_obj(DICT_VENDOR, v)
del v
d.dump()
d.vendors_list()

# New application
a = dict_application_data()
a.application_id = 99
a.application_name = "My test appl"
my_appl = d.new_obj(DICT_APPLICATION, a, my_vendor)
del a

# New type (callbacks are not supported yet...)
t = dict_type_data()
t.type_base = AVP_TYPE_INTEGER32
t.type_name = "My integer AVP"
my_type_int = d.new_obj(DICT_TYPE, t, my_appl)
t.type_base = AVP_TYPE_OCTETSTRING
t.type_name = "My binary buffer AVP"
my_type_os = d.new_obj(DICT_TYPE, t, my_appl)
del t

# Constants
c = dict_enumval_data()
c.enum_name = "AVP_VALUE_TROIS"
c.enum_value.i32 = 3
d.new_obj(DICT_ENUMVAL, c, my_type_int)

c.enum_name = "A_BUFFER_CONSTANT"
c.enum_value.os = "This is a very long AVP value that we prefer to represent as a constant"
c.enum_value.os.dump()
d.new_obj(DICT_ENUMVAL, c, my_type_os)
del c

# AVP
a = dict_avp_data()
a.avp_code = 234
a.avp_name = "my integer avp"
a.avp_flag_mask = AVP_FLAG_MANDATORY
a.avp_basetype = AVP_TYPE_INTEGER32
my_avp_int = d.new_obj(DICT_AVP, a, my_type_int)

a.avp_vendor = 123
a.avp_name = "my OS avp"
a.avp_flag_mask = AVP_FLAG_MANDATORY + AVP_FLAG_VENDOR
a.avp_flag_val = AVP_FLAG_VENDOR
a.avp_basetype = AVP_TYPE_OCTETSTRING
my_avp_os = d.new_obj(DICT_AVP, a, my_type_os)
del a

# Command
c = dict_cmd_data()
c.cmd_code = 345
c.cmd_name = "My-Python-Request"
c.cmd_flag_mask = CMD_FLAG_REQUEST + CMD_FLAG_PROXIABLE
c.cmd_flag_val = CMD_FLAG_REQUEST + CMD_FLAG_PROXIABLE
my_req = d.new_obj(DICT_COMMAND, c, my_appl)
c.cmd_name = "My-Python-Answer"
c.cmd_flag_val = CMD_FLAG_PROXIABLE
my_ans = d.new_obj(DICT_COMMAND, c, my_appl)
del c

# Rule
r = dict_rule_data()
r.rule_avp = my_avp_int
r.rule_position = RULE_REQUIRED
r.rule_min = -1
r.rule_max = -1
d.new_obj(DICT_RULE, r, my_req)
d.new_obj(DICT_RULE, r, my_ans)
r.rule_avp = my_avp_os
d.new_obj(DICT_RULE, r, my_req)
d.new_obj(DICT_RULE, r, my_ans)
del r

d.dump()
del d


####### Now play with the "real" dictionary

gdict = cvar.fd_g_config.cnf_dict

appl = gdict.search ( DICT_APPLICATION, APPLICATION_BY_ID, 3 )
appl.dump()
avp = gdict.search ( DICT_AVP, AVP_BY_NAME, "Origin-Host")
avp.dump()
errcmd = gdict.error_cmd()

v = avp.getval()
print v.avp_code
del v

t = avp.gettype()
print t
del t

dict = avp.getdict()
del dict


############# Sessions ############

# handler
def my_cleanup(state,sid):
    print "Cleaning up python state for session:", sid
    print "Received state:", state
    del state

hdl = session_handler(my_cleanup)
hdl.dump()
del hdl

# Session
hdl = session_handler(my_cleanup)
s1 = session()
s1.getsid()
s2 = session("this.is.a.full.session.id")
r,s3,isnew = fd_sess_fromsid("this.is.a.full.session.id")
s4 = session("host.id", "optional.part")
s4.settimeout(30) # the python wrapper takes a number of seconds as parameter for simplicity
s4.dump()

# states
mystate = [ 34, "blah", [ 32, 12 ] ]
s1.store(hdl, mystate)
del mystate
gotstate = s1.retrieve(hdl)
print gotstate
del gotstate


############# Routing ############

rd = rt_data()

rd.add("p1.testbed.aaa", "testbed.aaa")
rd.add("p2.testbed.aaa", "testbed.aaa")
rd.add("p3.testbed.aaa", "testbed.aaa")
rd.add("p4.testbed.aaa", "testbed.aaa")

rd.remove("p2.testbed.aaa")

rd.error("p3.testbed.aaa", "relay.testbed.aaa", 3002)

list = rd.extract(-1)
for c in list.enum_as("struct rtd_candidate *"):
  print "%s (%s): %s" % (c.diamid, c.realm, c.score)



############# Messages, AVPs ############

## AVP

# Create empty (as for messages, pass None or a dictionary object as 1st param, and flags as optional 2nd param)
blank_avp = avp()
del blank_avp

oh = avp(cvar.fd_g_config.cnf_dict.search ( DICT_AVP, AVP_BY_NAME, "Origin-Host"))	                # Octet String
vi = avp(cvar.fd_g_config.cnf_dict.search ( DICT_AVP, AVP_BY_NAME, "Vendor-Id"))                        # U32
vsai = avp(cvar.fd_g_config.cnf_dict.search ( DICT_AVP, AVP_BY_NAME, "Vendor-Specific-Application-Id")) # Grouped

# Set values
val = avp_value()
val.u32 = 123
vi.setval(None)  # this cleans a previous value (not needed)
vi.setval(val)
val.os = "my.origin.host"
oh.setval(val)
vsai.add_child(vi) # call as add_child(vi, 1) to add the new AVP at the beginning, default is at the end


## Messages

# Create empty
a_msg = msg()
a_msg.dump()
del a_msg

# It is also possible to pass MSGFL_* flags in second parameter (ALLOC_ETEID is default)
msg_no_eid = msg(None, 0)
msg_no_eid.dump()
del msg_no_eid

# Create from dictionary
dwr_dict = cvar.fd_g_config.cnf_dict.search ( DICT_COMMAND, CMD_BY_NAME, "Device-Watchdog-Request" )
dwr = msg(dwr_dict)
dwr.dump()

# Create msg from a binary buffer (then you should call parse_dict and parse_rules methods)
dwr2 = msg("\x01\x00\x00\x14\x80\x00\x01\x18\x00\x00\x00\x00\x00\x00\x00\x00\x1b\xf0\x00\x01")

# Create answer from request (optional parameters: dictionary to use, and flags):
dwr3 = msg(cvar.fd_g_config.cnf_dict.search ( DICT_COMMAND, CMD_BY_NAME, "Device-Watchdog-Request" ))
dwa3 = dwr3.create_answer()
dwr3cpy = dwa3.get_query()


## Other functions with AVPs & messages

# Add the AVPs in the message
dwr.add_child(oh)
oh.add_next(vsai)   # equivalent to add_child on the parent

# Create a network byte buffer from the message
dwr.bufferize()

# Get first child AVP (fast)
avp = dwr.first_child()

# then:
avp = avp.get_next() # when last AVP, returns None


# Get all 1st level children (slower) -- warning, changes to the python list will not be reflected on the underlying message. read-only use.
dwr.children()
# example use:
for a in dwr.children()
  a.dump(0)  # 0 means: dump only this object, do not walk the tree


# Search the first AVP of a given type
oh_dict = cvar.fd_g_config.cnf_dict.search( DICT_AVP, AVP_BY_NAME, "Origin-Host")
oh = dwr.search( oh_dict )

# After adding AVPs, the length in the message header is outdated, refresh as follow:
dwr.update_length()

# Get dictionary model for a message or avp
dwr.model()
oh.model().dump()

# Retrieve the header of messages & avp:
dwr_hdr = dwr.header()
dwr_hdr.msg_version
dwr_hdr.msg_hbhid

oh_hdr = oh.header()
hex(oh_hdr.avp_flags)
oh_hdr.avp_vendor
oh_hdr.avp_value.os.dump()  # The initial avp value must be set with setval(), but then this accessor is allowed.

# Get or set the routing data
rd = rt_data()
dwr.set_rtd(rd)
rd = dwr.get_rtd()

# Test if message is routable
dwr.is_routable()

# Which peer the message was received from (when received from network)
dwr.source()

# The session corresponding to this message (returns None when no Session-Id AVP is included)
dwr.get_session()


# Parse a buffer
buf = "\x01\x00\x00@\x80\x00\x01\x18\x00\x00\x00\x00\x00\x00\x00\x00N\x10\x00\x00\x00\x00\x01\x08@\x00\x00\x16my.origin.host\x00\x00\x00\x00\x01\x04@\x00\x00\x14\x00\x00\x01\n@\x00\x00\x0c\x00\x00\x00{"
mydwr = msg(buf)
# Resolve objects in the dictionary. Return value is None or a struct pei_error in case of problem.
mydwr.parse_dict()  # if not using the fD global dict, pass it as parameter
err = mydwr.parse_rules()
err.pei_errcode


# Grouped AVPs are browsed with same methods as messages:
gavp = dwr.children()[1]
gavp.first_child().dump()
gavp.children()










######################### old stuff (need update) ######################


# Create a new peer_info structure and add the peer to the framework.
mypeer = peer_info()
mypeer.pi_diamid = "nas.testbed.aaa"
mypeer.config.pic_flags.pro4 = 1   # 1 for TCP, for some reason PI_P4_TCP is not defined
fd_peer_add(mypeer, "python", None, None)
del mypeer

